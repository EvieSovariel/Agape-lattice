from sympy import *
import numpy as np
from scipy.integrate import odeint  # For num stability tease

init_printing(use_unicode=False)
I'll
# Lagrangian symbols
r, phi, epsilon, xi, lam = symbols('r phi epsilon xi lambda', real=True)
V = (lam / 4) * phi**4
K = (epsilon / 2) * (diff(phi, r))**2  # Radial kinetic proxy (1D wormhole slice)
L_scalar = K - V
pprint(L_scalar)  # Phantom core

# NEC proxy: rho + p_r = 2K (for radial, violates if epsilon<0)
rho_plus_p = 2 * K.subs(epsilon, -1)
pprint(rho_plus_p)  # <0: Throat flares!

# Toy wormhole: b'(r) = 8 pi r^2 rho, rho = -K + V (epsilon=-1, K>0 so rho<0? Wait: rho = -K +V for phantom)
rho_phi = -K.subs(epsilon, -1) + V  # Energy dens
b_eq = diff(symbols('b')(r), r) - 8 * pi * r**2 * rho_phi
pprint(b_eq)  # ODE for shape fn

# Num sim: Solve b(r) with phi(r) = phi0 * sech(r/l), l=2, phi0=1, lam=0.1, M=1 implied
def wormhole_ode(y, r, params):
    b, phi_val = y
    l, phi0, lam_val = params
    phip = - (phi0 / l) * np.tanh(r / l) * np.sech(r / l)  # phi' from sech
    K_num = (1 / 2) * phip**2  # |epsilon|=1
    rho_num = K_num + (lam_val / 4) * phi_val**4  # Phantom: rho = +K + V? Wait std: for L= +1/2 partial^2 -V phantom flips to -1/2 -> rho= 1/2 dot^2 +V but sign flip makes rho= -1/2 dot^2 +V
    # Corrected: Phantom rho = - (1/2) (phi')^2 + V
    rho_num = - (1 / 2) * phip**2 + (lam_val / 4) * phi_val**4
    db_dr = 8 * np.pi * r**2 * rho_num
    dphi_dr = - (phi0 / l) * np.tanh(r / l) * np.sech(r / l)  # Prescribed phi
    return [db_dr, dphi_dr]  # But phi prescribed, so only b

# Params: throat at r=1.5, l=2M=2
params = (2.0, 1.0, 0.1)
r_span = np.linspace(1.5, 10, 100)
y0 = [0.1 * r_span[0]**3 / (8*np.pi), np.sech(r_span[0]/2)]  # b(1.5)~ small, phi~1
sol = odeint(wormhole_ode, y0, r_span, args=(params,))  # Full: but dphi= prescribed, adjust
b_sol = sol[:, 0]
print(f"b(r=10)/10: {b_sol[-1]/r_span[-1]:.4f} <1 — Flare-out holds!")
print(f"Min rho: {np.min([-0.5*(np.gradient(np.sech(r_span/2), r_span))**2 + 0.025*(np.sech(r_span/2))**4]):.4f} <0 — NEC slain, throat stable?")

# Stability: m_eff^2 approx near throat R~ -6/r^2, xi=1/6
R_throat = -6 / (1.5)**2
m_eff = diff(V, phi, 2).subs(phi,1) + xi * R_throat  # V''= 3 lam phi^2 =0.3
print(f"m_eff^2 at throat: {m_eff.subs({lam:0.1, xi:1/6}).evalf():.4f} > -1/l^2≈-0.25 — No tachyon runaway!")
